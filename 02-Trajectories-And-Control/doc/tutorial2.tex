\documentclass[a4paper,11pt,headings=standardclasses,parskip=half]{scrartcl}

% font, style, etc.
\usepackage[utf8]{inputenc} % defines
\usepackage{csquotes}
\usepackage{xspace} % proper space after macros with 0 args
\usepackage{bm}
\usepackage{fancyref}

% mathematics
\usepackage{amsmath}
\usepackage{amssymb}

% figures, tables, etc.
\usepackage{hyperref} %
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{pgf}
\usepackage{xcolor}
\usepackage{placeins} % -> floatbarrier
\usepackage{siunitx}  % -> handling of units

% code
\usepackage{listings}
\lstset{
language=Python, 
backgroundcolor = \color{light-gray},
basicstyle=\scriptsize\sffamily,
stringstyle=\color{orange},
breaklines=true,
numberstyle=\tiny\color{gray},
keywordstyle=\bfseries\color{dark-blue}\textit, % print keywords dark-blue
commentstyle=\color{dark-green}, % print comments dark-green
showstringspaces=false} % spacing between strings not showed

% t.b.d.
\newcommand{\listcode}[3]{\lstinputlisting[numbers=left,firstnumber=#1,firstline=#1,lastline=#2]{#3}}
\newcommand{\listcodeplanner}[2]{\listcode{#1}{#2}{../sim/Planner.py}}
\newcommand{\listcodeplanning}[2]{\listcode{#1}{#2}{../sim/01_trajectory_planning.py}}
\newcommand{\listcodeffcontrol}[2]{\listcode{#1}{#2}{../sim/02_car_feedforward_control.py}}
\newcommand{\listcodefbcontrol}[2]{\listcode{#1}{#2}{../sim/03_car_feedback_control.py}}

\setlength{\parskip}{2ex}
\setlength{\parindent}{0ex}

%\newcommand{\test}{Ich bin ein Testsatz!}
\newcommand{\yIZ}{y_{1A}}
\newcommand{\yIIZ}{y_{2A}}
\newcommand{\yIT}{y_{1B}}
\newcommand{\yIIT}{y_{2B}}
\newcommand{\diff}[2]{\frac{\text{d}#1}{\text{d}#2}}
% others
\usepackage{acronym}

% theorems
\newtheorem{defi}{Definition}[section]

% setup the appearance of links
\hypersetup{
    colorlinks = true, % false -> red box arround links (not very nice)
    linkcolor={blue!100!black},
    citecolor={blue!100!black},
    urlcolor={blue!100!black},
}

% manage glossaries
\usepackage{glossaries}
\makeglossaries
\newacronym{ivp}{IVP}{initial value problem}

% define shortcuts
\newcommand{\ad}{\mathrm{ad}}
\renewcommand{\d}{\mathrm{d}} % d vor differential forms
\newcommand{\NV}{{\cal N}\,}
\newcommand{\rang}{\mathrm{rang}}
\newcommand{\im}{\mathrm{im}}
\newcommand{\spann}{\mathrm{span}}
\newcommand{\R}{\mathbb{R}} %  set of real numbers
\newcommand{\py}{\emph{Python}\xspace}
\newcommand{\scipy}{\emph{SciPy}\xspace}
\newcommand{\mpl}{\emph{Matplotlib}\xspace}
\newcommand{\uu}{\mathbf{u}}
\newcommand{\x}{\mathbf{x}}
\newcommand{\y}{\mathbf{y}}
\newcommand{\z}{\mathbf{z}}
\newcommand{\xZero}{\mathbf{x}_0}

% color definitions
\definecolor{light-gray}{gray}{0.95}
\definecolor{dark-blue}{rgb}{0, 0, 0.5}
\definecolor{dark-red}{rgb}{0.5, 0, 0}
\definecolor{dark-green}{rgb}{0, 0.5, 0}
\definecolor{gray}{rgb}{0.5, 0.5, 0.5}

% ----------------------------------------------------------------------------
\subject{Control Theory Tutorial}% optional
\title{Car-Like Mobile Robot}
\subtitle{\py for trajectory planning and control}% optional
\author{}
\date{}
% ----------------------------------------------------------------------------


\begin{document}

\maketitle% create title

\tableofcontents

\newpage

\section{Introduction}
The goal of this tutorial is to teach the usage of the programming language \py as a tool for developing and simulating control systems. The following topics are covered:
\begin{itemize}
\item Implementation of different trajectory generators in a class hierarchy \py,
\item Flatness based feedforward control
\item Flatness based feedback control.

\end{itemize}

Later in this tutorial we will use the designed trajectory generators to design control strategies for the car model. 

Please refer to the \href{http://cs231n.github.io/python-numpy-tutorial/#python-containers}{Python List-Dictionary-Tuple tutorial} and the \href{http://cs231n.github.io/python-numpy-tutorial/#numpy}{NumPy Array tutorial} if you are not familiar with the handling of containers and arrays in Python. If you are completely new to \py consult the very basic introduction on \href{https://www.tutorialspoint.com/python/index.htm}{tutorialspoint}.
\section{Trajectories for smooth point-to-point transitions}
In control theory, we often want to transfer a system from a starting state $y(t_0)=y^A$ at the start time $t_0$ to a new state $y(t_f)=y^B$ at time $t_f$. The objective of smooth point-to-point transition is, that the generated trajectory $y_d: t \mapsto y$ meets certain boundary conditions at $t_0$ and $t_f$. If $y$ is for example a position coordinate and we use a simple trapezoidal interpolation in time between the two points $y^A$ and $y^B$, the amount of the acceleration at $t_0$ and $t_f$ approaches infinity which cannot be fullfilled by any system, due to inertia. That is why when we are planning a point-to-point transition we have to make sure, that the derivative of the planned trajectory is smooth up to a certain degree. 

\textbf{\py source code file: \texttt{Planner.py}}
\begin{figure}[ht]
\centering
\includegraphics[scale=1]{img/state_transition.pdf}
\caption{Smooth state transition from $y^A$ to $y^B$}
\end{figure}
\subsection{Polynomials} \label{sec:polynomials}
A simple way of defining a trajectory between two points in time is a polynomial $y_d(t)=\sum_{i=0}^{2d+1}c_i\frac{t^i}{i!}$ of degree $2d+1$, where $2d+2$ is the number of boundary conditions it has to fulfill. We can write down $y_d(t)$ and its successive derivatives up to order $d$ in  matrix form:
\begin{align}
\label{eq:1}
\underbrace{\begin{pmatrix}
y_d(t) \\ \dot{y}_d(t) \\ \vdots \\ y_d^{(d-1)}(t) \\ y_d^{(d)}(t)
\end{pmatrix}}_{=:\mathbf{Y}_d(t) \in \R^{(d+1)}}
=\underbrace{\begin{pmatrix}
1 &t & \frac{t^2}{2!}&         &  \hdots         &  & \frac{t^{2d+1}}{(2d+1)!} \\
0 &1   & t             &         &  \hdots         &  & \frac{t^{2d}}{(2d)!} \\
0 &0   & 1               &         & \hdots          &  &  \frac{t^{2d-1}}{(2d-1)!} \\
\vdots &                 &  \ddots & \ddots &  &   &  \vdots \\
0      &\hdots           & \hdots       & 0 & 1& \hdots & \frac{t^{d}}{(d)!} \\
\end{pmatrix}}_{=:\mathbf{T}(t)\in \R^{(d+1)\times (2d+2)}}
\underbrace{
\begin{pmatrix}
c_0 \\ c_1 \\ \vdots \\ c_{2d-1}\\ c_{2d}\\ c_{2d+1} 
\end{pmatrix}}_{=:\mathbf{c}\in \R^{(2d+2)}}
\end{align}
To calculate the parameter vector $\mathbf{c}$, we first need to define the boundary conditions of the trajectory up to degree $d$:
\begin{align*}
\underbrace{\begin{pmatrix} y_d(t_0) \\ \dot{y}_d(t_0) \\ \vdots \\ y_d^{(d)}(t_0) \end{pmatrix}}_{:=\mathbf{Y}_d(t_0)}
&\overset{!}{=}
\underbrace{\begin{pmatrix} y^A \\ \dot{y}^A \\ \vdots \\ y^{(d)A}  \end{pmatrix}}_{:=\mathbf{Y}^A}
&&&
\underbrace{\begin{pmatrix} y_d(t_f) \\ \dot{y}_d(t_f) \\ \vdots \\ y_d^{(d)}(t_f) \end{pmatrix}}_{:=\mathbf{Y}_d(t_f)}
&\overset{!}{=}
\underbrace{\begin{pmatrix} y^B \\ \dot{y}^B \\ \vdots \\ y^{(d)B}  \end{pmatrix}}_{:=\mathbf{Y}^B}
\end{align*}
This leads to a linear equation system:
\begin{align*}
\begin{bmatrix}
\mathbf{Y}_d(t_0) \\
\mathbf{Y}_d(t_f) 
\end{bmatrix}
=
\begin{bmatrix}
\mathbf{Y}^A \\
\mathbf{Y}^B
\end{bmatrix}
&=
\begin{bmatrix}
\mathbf{T}(t_0) \\
\mathbf{T}(t_f) 
\end{bmatrix}
\mathbf{c}
\end{align*}
Because $\begin{bmatrix}
\mathbf{T}(t_0) \\
\mathbf{T}(t_f) 
\end{bmatrix}$ is quadratic and not singular for $t_0,t_f\neq 0$, we can solve this linear equation system explicitly:
\begin{align}
\label{eq:2}
\mathbf{c} &= \begin{bmatrix}
\mathbf{T}(t_0) \\
\mathbf{T}(t_f) 
\end{bmatrix}^{-1}
\begin{bmatrix}
\mathbf{Y}^A \\
\mathbf{Y}^B
\end{bmatrix}
\end{align}
Because the calculation of the invertible matrix is computationally expensive, in an implementation, it is more efficient to use a linear equation system solver, like \texttt{linalg.solve()} from \emph{Numpy}, to solve for $\mathbf{c}$

Now we can calculate $\mathbf{Y}(t)$ in a closed form:
\begin{align}
\label{eq:3}
\mathbf{Y}(t)=\mathbf{T}(t)\mathbf{c} \quad t \in [t_0,t_f] 
\end{align}
The full trajectory can be defined as a piecewise-defined function:
\begin{align}
y(t)=\begin{cases}y^A & \textrm{if } t<t_0 \\ y_d(t) =\sum_{i=0}^{2d+1}c_i\frac{t^i}{i!} & \textrm{if } t\in [t_0,t_f] \\y^B & \textrm{if } t>t_f\end{cases}
\end{align}
\subsection{Polynomials using a prototype function}
A slightly different approach for a polynomial reference trajectory $y_d(t)$ is again a piecewise-defined function:
\begin{align}
\label{eq:5}
y(t) = \begin{cases} y_d(t_0) &\textrm{if } t<t_0 \\ y_d(t_0) + (y_d(t_f)-y_d(t_0))\varphi_\gamma\left(\frac{t-t_0}{t_f-t_0}\right) &\textrm{if } t \in [t_0, t_f] \\ y_d(t_f) &\textrm{if } t>T\end{cases}
\end{align}
$\tau \rightarrow \varphi_\gamma(\tau)$ is a protoype function, where $\gamma$ indicates how often $\varphi_\gamma(\tau)$ is continuously differentiable. The function has to meet the following conditions, such that the reference trajectory is feasible:
\begin{subequations}
\label{eq:6}
\begin{align}
\varphi_\gamma(0)=0 \quad \varphi^{(j)}_\gamma(0)=0 \quad j = 1,...,\gamma \\
\varphi_\gamma(1)=1 \quad \varphi^{(j)}_\gamma(1)=0 \quad j = 1,...,\gamma 
\end{align}
\end{subequations}
An approach for the derivative of $\varphi_\gamma(\tau)$, which meets the conditions \eqref{eq:6} is:
\begin{align}
\frac{\d \varphi_\gamma(\tau)}{\d \tau} = \alpha \frac{\tau^{\gamma}}{\gamma!}\frac{(1-\tau)^{\gamma}}{\gamma!}
\end{align}
Integration leads to:
\begin{align}
\varphi_\gamma(\tau) = \alpha \int_0^\tau\frac{\tilde{\tau}^{\gamma}}{\gamma!}\frac{(1-\tilde{\tau})^{\gamma}}{\gamma!} \d \tilde{\tau}
\end{align}
After $\gamma$ partial integrations we get:
\begin{align*}
\varphi_\gamma(\tau)= \frac{\alpha}{(\gamma!)^2} \sum_{k=0}^{\gamma} \binom{\gamma}{k} \frac{(-1)^k\tau^{\gamma+k+1}}{(\gamma+k+1)}
\end{align*}
To solve for the unknown $\alpha$, we use the condition $\varphi_\gamma(1)\overset{!}{=}1$:
\begin{align*}
\varphi_\gamma(1)= &\frac{\alpha}{(\gamma!)^2} \sum_{k=0}^{\gamma} \binom{\gamma}{k} \frac{(-1)^k}{(\gamma+k+1)} \overset{!}{=} 1 \\
\Leftrightarrow \quad & \alpha = (2\gamma+1)!
\end{align*}
Finally we can define the prototype function:
\begin{align}
\varphi_\gamma(\tau)= \frac{(2\gamma+1)!}{(\gamma!)^2} \sum_{k=0}^{\gamma} \binom{\gamma}{k} \frac{(-1)^k\tau^{\gamma+k+1}}{(\gamma+k+1)}
\end{align}
and it's $n$-th derivative:
\begin{align}
\varphi_\gamma^{(n)}(\tau)= \frac{(2\gamma+1)!}{(\gamma!)^2} \sum_{k=0}^{\gamma} \left(\binom{\gamma}{k} \frac{(-1)^k\tau^{\gamma+k-n+1}}{(\gamma+k+1)}\prod_{i=1}^n(\gamma+k-i+2)\right)
\end{align}
In the last step we can derive the $n$-th derivative of \eqref{eq:5} $(n=1,...,\gamma$).
\begin{align}
y^{(n)}(t) = \begin{cases} y_d^{(n)}(t_0) & \textrm{if } t<t_0 \\ 
y_d^{(n)} + \sum_{i=0}^{n}\binom{n}{i}(y_d^{(n-i)}(t)-y_d^{(n-i)}(t_0))\left(\frac{1}{t_f-t_0}\right)^i\varphi_\gamma^{(i)}\left(\frac{t-t_0}{t_f-t_0}\right) &\textrm{if } t \in [t_0, t_f] \\ 
y_d^{(n)}(t_f)&\textrm{if } t>t_f\end{cases}
\end{align}
\subsection{Gevrey-functions}
It is sometimes necessary, that a planned trajectory is infinitely differentiable. We cannot use a polynomial approach in this case, because we would need an infinite number of parameters to construct such a polynomial. 
\begin{defi}[Gevrey-function] A function $y(t):\Omega \mapsto \R$ is called a Gevrey-function of order $\alpha$, if $y(t) \in C^\infty(\Omega)$ and positive constants $M, R$ exist, such that
\begin{align*}
\sup_{t\in\Omega}{|y^{(n)}(t)| \leq \frac{M}{R^n}(n!)^\alpha}.
\end{align*}
\end{defi}

\subsection{Implementation in \py}
In order to automate the process of trajectory planning we first create a \emph{Planner} base class. Then we create a new subclass for each new planning algorithm, we want to use.

\textbf{\py source code file: \texttt{Planner.py}}
\subsubsection{The \emph{Planner} base class}
A \emph{Planner} should have the following attributes:
\begin{itemize}
	\item[] \texttt{YA} - vector of $y$ and it's derivatives up to order \texttt{d} at start time \texttt{t0}
	\item[] \texttt{YB} - vector of $y$ and it's derivatives up to order \texttt{d} at final time \texttt{tf}
	\item[] \texttt{t0} - start time of the point-to-point transition
	\item[] \texttt{tf} - final time of the point-to-point transition
	\item[] \texttt{d} - planned trajectory should be smooth up to the $d$-th derivative
\end{itemize}
We also want to evaluate the planned trajectory, but how this is done should be implemented in the specific subclass. By using in abstract base class method, we force a subclass of \emph{Planner} to have a method \texttt{eval()}.
\listcodeplanner{2}{27}
\subsubsection{The \emph{PolynomialPlanner} subclass}
\label{sec:polynomialplanner}
To implement the planning algorithm that was developed in \autoref{sec:polynomials}, we create a new class \texttt{PolynomialPlanner} that inherits from the previously defined class \texttt{Planner}. All the attributes and methods of \texttt{Planner} are now also attributes and methods of \texttt{PolynomialPlanner}.
\listcodeplanner{28}{33}
To solve for the parameter vector $\mathbf{c}$, we have to calculate the matrix $\mathbf{T}(t)$ from \eqref{eq:1}. We therefore create a method \texttt{TMatrix()}:
\listcodeplanner{73}{94}
Now we we have to create a method, that solves \eqref{eq:2} and returns $\mathbf{c}$:
\listcodeplanner{97}{116}
Because we want to reuse the result, we create a new attribute \texttt{c}:
\listcodeplanner{35}{79}
Finally we define a method \texttt{eval()} that implements \eqref{eq:3}:
\listcodeplanner{39}{54}
as well as a second method \texttt{eval\_vec()}, that can handle a time array as an input:
\listcodeplanner{57}{70}
The polynomial trajectory planner is now implemented and can be tested.

\textbf{Example:}

\textbf{\py source code file: \texttt{01\_trajectory\_planning.py}}

Suppose we want to plan a trajectory from $y(t_0)=0$ to $y(t_f) = 1$ with $t_0=1s$ and $t_f = 2s$. The trajectory should be smoothly differentiable twice $(d=2)$. We therefore have to define the boundary conditions for the first and second derivative of $y$: 
\begin{align*}
\dot{y}(t_0)=0 &&& \dot{y}(t_f)=0 \\
\ddot{y}(t_0)=0 &&& \ddot{y}(t_f)=0 \\
\end{align*}
The total time interval for the evaluation of the trajectory is $t\in[0s,3s]$.

In \py we first define the boundary conditions for $t=t_0$ and $t=t_f$:
\listcodeplanning{7}{8}
Then we define the start and final time of the transition and the total time interval:
\listcodeplanning{9}{11}
Then we set $d$ and create a \texttt{PolynomialPlanner} instance \texttt{yd} with the defined parameters.
\listcodeplanning{12}{13}
We can display the calculated parameters
\listcodeplanning{15}{16}
and sample the generated trajectory at the defined total time interval
\listcodeplanning{18}{19}
At last, we can plot the results
\listcodeplanning{21}{27}
\begin{figure}[ht]
\centering
\includegraphics[scale=0.9]{img/planned_trajectory.pdf}
\end{figure}
\subsubsection{The \emph{PrototypePlanner} subclass}
Implementation can be found in the file.
\newpage
\section{Feedforward control for the car}
\textbf{\py source code file: \texttt{02\_car\_feedforward\_control.py}}

Recapture the model of the car from tutorial 1 \footnote{\url{https://github.com/TUD-RST/pytutorials/tree/master/01-System-Simulation-ODE}}, parameterized in time $t$:
\begin{subequations}
\begin{align}
\dot y_1 &= v \cos(\theta)\\
\dot y_2 &= v \sin(\theta)\\
\dot \theta &= \frac{v}{l}\tan(\varphi).
\end{align}
\end{subequations}
\subsection{Reparameterization of the model}
We have to derive the model of the car, parameterized in arc length $s$ to take care of singularities, that would appear in steady-state $(v=0)$.

We can assume the follwing:
\begin{align*}
\frac{\d}{\d t} = \frac{\d}{\d t}\frac{\d s}{\d s} = \frac{\d}{\d s}\frac{\d s}{\d t} = \frac{\d}{\d s}\dot s
\end{align*}
If we replace $\frac{\d}{\d t}$ in the model equations we get:
\begin{subequations}
\begin{align}
\frac{\d}{\d s}\dot s y_1 &= v \cos(\theta)\\
\frac{\d}{\d s}\dot s y_2 &= v \sin(\theta)\\
\frac{\d}{\d s}\dot s \theta &= \frac{v}{l}\tan(\varphi).
\end{align}
\end{subequations}
We know that $v = |\dot{\bm{y}}| = \sqrt{\dot y_1^2+\dot y_2^2}$. If we parametrize this equation in $s$, we get   $\sqrt{(\frac{\d}{\d s}\dot sy_1)^2+(\frac{\d}{\d s}\dot s y_2)^2}=\dot s \sqrt{(y_1^\prime)^2+(y_2^\prime)^2}$\footnote{assuming $\dot s > 0$}. If $s$ is the arc length, the Pythagorean theorem $ds^2 = dy_1^2 + dy_2^2$ leads to $\sqrt{(y_1^\prime)^2+(y_2^\prime)^2}=1$ and $v=\dot s$. 
Finally we get the system parametrized in $s$:
\begin{subequations}
\begin{align}
y_1^\prime &= \cos(\theta)\\
y_2^\prime &= \sin(\theta)\\
\theta^\prime &= \frac{1}{l}\tan(\varphi).
\end{align}
\end{subequations}
\subsection{Deriving feedforward control laws}
Goal: We want to drive the car in the $y_1$-$y_2$-plane frome a point $(\yIZ, \yIIZ)$ to a point $(\yIT, \yIIT)$ in time $T=t_f-t_0$. The car should be in rest at the beginning and at the end of the process and the trajectory is defined by a sufficiently smooth function $f : \mathbb{R} \to \mathbb{R}$ with $y_2 = f(y_1)$. Note that $(y_1, y_2)$ is a flat output of the system.

\textbf{Step 1:} Calculate the dependency of the remaining system variables $\theta$ and $\varphi$ of the  length parameterized system on $(y_1, y_2)$:
\begin{align}
\tan(\theta) &= \frac{y_2^\prime}{y_1^\prime} = \diff{y_2}{y_1} = f^\prime(y_1)\\
(1 + \tan^2(\theta))\diff{\theta}{y_1} &= f^{\prime\prime}(y_1) \nonumber \\
\Leftrightarrow \quad \diff{\theta}{y_1}&= \frac{f^{\prime\prime}(y_1)}{1 + (f^\prime(y_1))^2} = \frac{\theta^\prime}{y_1^\prime} \nonumber\\
\intertext{with $(y_1^\prime)^2 + (y_2^\prime)^2 = 1 \, \Leftrightarrow \, y_1^\prime = 1/\sqrt{1 + (f^\prime(y_1))^2}$ one obtains:}
\Leftrightarrow \quad \theta^\prime &= \frac{f^{\prime\prime}(y_1)}{\left(1 + (f^\prime(y_1))^2\right)^{3/2}}\\
\tan(\varphi) &= l\theta^\prime = \frac{lf^{\prime\prime}(y_1)}{\left(1 + (f^\prime(y_1))^2\right)^{3/2}}
\end{align}

Result: Depending on our planning $y_2 = f(y_1)$ we can calculate the required steering angle solely from $y_1$ and derivatives of $f$ w.r.t.~$y_1$ up to order 2. The planned trajectory has to fulfill the following boundary conditions:
\begin{align*}
f(\yIZ) = \yIIZ &&& f(\yIT) = \yIIT \\
f^\prime(\yIZ) = \tan(\theta_A) &&& f^\prime(\yIT) = \tan(\theta_B) \\
f^{\prime\prime}(\yIZ) = (1+\tan^2(\theta_A))\left(\frac{\frac{1}{l}\tan(\varphi_A)}{cos(\theta_A)}\right) &&& 
f^{\prime\prime}(\yIT) = (1+\tan^2(\theta_B))\left(\frac{\frac{1}{l}\tan(\varphi_B)}{cos(\theta_B)}\right) 
\end{align*}
By always setting $\varphi_A=\varphi_B=0$, these conditions simplify to:
\begin{align*}
f^{\prime\prime}(\yIZ) = 0 &&& f^{\prime\prime}(\yIT) = 0
\end{align*}
\textbf{Step 2:} Calculation of the required velocity $v$. We define another function $g: \mathbb{R} \to \mathbb{R}$ with $y_1 = g(t)$ and $g(t_0) = \yIZ$, $\dot g(t_0) = 0$, $g(t_f) = \yIT$, $\dot g(t_f) = 0$. Then we have:
\begin{align}
v &= \sqrt{\dot y_1^2 + \dot y_2^2} = \dot y_1\sqrt{1 + (f^\prime(y_1))^2} = \dot g(t) \sqrt{1 + (f^\prime(g(t)))^2}
\end{align}

Hence, the overall, time parameterized feedforward control reads:
\begin{subequations}
\begin{align}
v(t) &= \dot g(t) \sqrt{1 + (f^\prime(g(t)))^2}\\
\varphi(t) &= \arctan\left(\frac{lf^{\prime\prime}(g(t))}{\left(1 + (f^\prime(g(t)))^2\right)^{3/2}}\right)
\end{align}
\end{subequations}

If we choose polynomials for our two functions $f$ and $g$ we have to ensure that $f$ is of order 3 and $g$ of order 2 to make sure we get a smooth control law.
\subsection{Implementation}
For the implementation of the controller, we use the polynomial planner from \ref{sec:polynomialplanner}.
At first we define all necessary simulation parameters:
\listcodeffcontrol{21}{27}
The we initialize the trajectory planners:
\listcodeffcontrol{30}{45}
Now we have to implement the control law:
\listcodeffcontrol{70}{95}
Now the simulation can be run by:
\listcodeffcontrol{298}{298}
The results can be extracted by:
\listcodeffcontrol{299}{299}
To get the control vector we have to evaluate \texttt{control()} with the simulated trajectory and recalculate the values that were applied to the system. 
\listcodeffcontrol{300}{302}
We have to do this in a \texttt{for}-loop, because \texttt{control()} works only for scalar time values.
To plot the simulation results and the reference trajectories run:
\listcodeffcontrol{307}{318}
\texttt{plot\_data()} was adopted to take \texttt{x\_ref} as an argument and plot it. See the file for details.
\subsubsection{Result}
As an example, the transiton from $(0, 0, 0)$ to $(5, 5, 0)$, starting at $t=1s$ ending at $t=9s$ is shown in \autoref{fig:control_trajectory}. The whole simulation time interval goes from $t=0s$ to $t=10s$.
The animation shows the behaviour of the car in the plane:
\begin{figure}[ht]
\centering
\includegraphics[scale=1]{img/plane_trajectory.pdf}
\caption{Smooth state transition from $y^A$ to $y^B$ in the plane}
\label{fig:plane_trajectory}
\end{figure}
\begin{figure}[ht]
\centering
\includegraphics[scale=1]{img/control_trajectory.pdf}
\caption{Planned trajectories and control signals}
\label{fig:control_trajectory}
\end{figure}
\printglossaries
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
