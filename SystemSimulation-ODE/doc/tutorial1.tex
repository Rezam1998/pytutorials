\documentclass[a4paper,11pt,headings=standardclasses]{scrartcl}% see <http://www.komascript.de>
% ----------------------------------------------------------------------------
% font, style, etc.
\usepackage[utf8]{inputenc} % defines
\usepackage{csquotes}

% mathematics
\usepackage{amsmath}
\usepackage{amssymb}

% figures, tables, etc.
\usepackage{hyperref} %
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{pgf}
\usepackage{xcolor}

% code
\usepackage{listings}
\lstset{
language=Python, 
backgroundcolor = \color{light-gray},
basicstyle=\scriptsize\sffamily,
stringstyle=\color{orange},
breaklines=true,
numberstyle=\tiny\color{gray},
keywordstyle=\bfseries\color{dark-blue}\textit, % print keywords dark-blue
commentstyle=\color{dark-green}, % print comments dark-green
showstringspaces=false} % spacing between strings not showed

% others
\usepackage{acronym}

% theorems
\newtheorem{defi}{Definition}[section]

% setup the appearance of links
\hypersetup{
    colorlinks = true, % false -> red box arround links (not very nice)
    linkcolor={red!20!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black},
}

% define shortcuts
\newcommand{\ad}{\mathrm{ad}}
\renewcommand{\d}{\mathrm{d}} % d vor differential forms
\newcommand{\NV}{{\cal N}\,}
\newcommand{\rang}{\mathrm{rang}}
\newcommand{\im}{\mathrm{im}}
\newcommand{\spann}{\mathrm{span}}
\newcommand{\R}{\mathbb{R}} %  set of real numbers
\newcommand{\py}{\emph{Python}\,}
\newcommand{\scipy}{\emph{SciPy}\,}
\newcommand{\mpl}{\emph{Matplotlib}\,}
\newcommand{\uu}{\mathbf{u}}
\newcommand{\x}{\mathbf{x}}
\newcommand{\y}{\mathbf{y}}
\newcommand{\z}{\mathbf{z}}
% color definitions
\definecolor{light-gray}{gray}{0.95}
\definecolor{dark-blue}{rgb}{0, 0, 0.5}
\definecolor{dark-red}{rgb}{0.5, 0, 0}
\definecolor{dark-green}{rgb}{0, 0.5, 0}
\definecolor{gray}{rgb}{0.5, 0.5, 0.5}

% ----------------------------------------------------------------------------
%\titlehead{Prof. Dr.-Ing. habli. Dipl.-Math. Klaus RÃ¶benack \\ Institute of Control Theory \\ Faculty of Electrical and Computer Engineering \\TU Dresden, Germany}% optional
\subject{Control Theory Tutorial}% optional
\title{Car-Like Mobile Robot}
\subtitle{\py for simulation, animation and control}% optional
\author{}
\date{}
%\publishers{}% optional
% ----------------------------------------------------------------------------

\begin{document}
\maketitle% create title
\tableofcontents
\newpage
\section{Introduction}
The goal of this tutorial is to teach the usage of the programming language \py as a tool for developing and simulating control systems.

\section{Model of a car-like mobile robot}
\label{sec:model}
\begin{figure}[ht]
	\centering
	\def\svgwidth{0.7\textwidth}
	\input{img/car-like_mobile_robot.pdf_tex}
	\caption{Car-like mobile robot}
	\label{fig:car}
\end{figure}
Given is a nonlinear kinematic model of a car-like mobile robot, with the following system variables: position $(y_1, y_2)$ and orientation $\theta$ in the plane, the steering angle $\phi$ and the robots lateral velocity $v=\left| \mathbf{v} \right| $. 
\begin{subequations}\label{eq:syseq}
\begin{align}
\dot{y}_1&=v \cos (\theta) \\
\dot{y}_2&=v \sin (\theta) \\
\tan(\phi) &= \frac{l\dot{\theta}}{v}
\end{align}
\end{subequations}
To simulate this system of 1st order ordinary differential equations (ODEs), we define a state vector $\x=(x_1,x_2,x_3)^\mathrm{T}$ and a control vector $\uu=(u_1,u_2)^\mathrm{T}$:
\begin{align*}
x_1 &= y_1 & u_1 = v\\
x_2 &= y_2 & u_2 = \phi \\
x_3 &= \theta 
\end{align*}
Now we can express \eqref{eq:syseq} in a general form $\dot{\x}=f(\x,\uu)$:
\label{eq:ss_system}
\begin{align}
\underbrace{\begin{pmatrix} \dot{x}_1 \\ \dot{x}_2 \\ \dot{x}_3 \end{pmatrix}}_{\dot{\x}} = \underbrace{\begin{pmatrix}  u_1 \cos(x_3) \\ u_1 \sin(x_3) \\ \frac{1}{l}u_1 \tan(u_2) \end{pmatrix}}_{f(\x,\uu)}
\end{align}

\section{Storing parameters}
We store the parameters of our system in a class \emph{Parameters()}.
\begin{lstlisting}
class Parameters(object):
    pass
\end{lstlisting}
We therefore create an entity of \emph{Parameters()} and assign attributes.
\begin{lstlisting}
prmtrs = Parameters() # entity of class Parameters
prmtrs.l = 0.3 # define car length
prmtrs.w = prmtrs.l*0.3 # define car width
\end{lstlisting}

\section{Libraries and Packages}
In order to use $\cos(\cdot), \sin(\cdot)$ and $\tan(\cdot)$ we need to import these functions at the beginning of our code from the \emph{numpy} library.
\begin{lstlisting}
import numpy as np 
from numpy import cos, sin, tan
\end{lstlisting}
To simulate \eqref{eq:ss_system} we need to solve an initial value problem (IVP). In \py we can use the library \scipy and its sub-package \emph{integrate}, which delivers different solvers for IVPs.
\begin{lstlisting}
from scipy.integrate import odeint
\end{lstlisting}
For plotting the output of our simulation, we use the library \mpl and its sub-package \emph{pyplot}, which delivers a user experience similar to \emph{MATLAB}.
\begin{lstlisting}
import matplotlib.pyplot as plt
\end{lstlisting}
\section{Simulation with SciPy's integrate package}
\label{sec:simulation}
\footnote{corresponding file: \emph{car-like\_mobile\_robot\_plotting.py}}
To simulate \eqref{eq:ss_system} we need to implement the ODE system as a function in \py.
\lstinputlisting[numbers=left,firstnumber=7,firstline=7,lastline=26]{../sim/car-like_mobile_robot_plotting.py}
The control law is also implemented as function.
\lstinputlisting[numbers=left,firstnumber=29,firstline=29,lastline=41]{../sim/car-like_mobile_robot_plotting.py}
As a first simple heuristic, we set $(u_1, u_2)$ equal to constant values. Later we can implement an arbitrary function, for expample a feedback law $\uu=k(\x)$.

\subsection{Solution of the initial value problem (IVP) using \scipy}
We then define the simulation time and the initial state value.
\lstinputlisting[numbers=left,firstnumber=98,firstline=98,lastline=106]{../sim/car-like_mobile_robot_plotting.py}
Now we can parse these parameters and our ODE function to the solver.
\lstinputlisting[numbers=left,firstnumber=108,firstline=108,lastline=110]{../sim/car-like_mobile_robot_plotting.py}
The output is an array of size length(tt)$\times$length($\x$).

\section{Plotting using \mpl}
\label{sec:plot}
We encase our plotting instructions in a function. This way, we can define parameters of our plot, which we would like to change easily, for example figure width, or if the figure should be saved on the hard drive.
% def plot_data():
\lstinputlisting[numbers=left,firstnumber=44,firstline=44,lastline=91]{../sim/car-like_mobile_robot_plotting.py}
Now that we have defined our plotting function, we  can execute it with the calculated trajectories and our desired values for the functions parameters.
\lstinputlisting[numbers=left,firstnumber=115,firstline=115,lastline=118]{../sim/car-like_mobile_robot_plotting.py}
If your not satisfied with the result, you can change other properties of the plot, like linewidth or -color and many others easily. Just look up the documentation of \mpl : \url{https://matplotlib.org/index.html}
\begin{figure}[h]
\label{fig:state_traj}
   \centering      
   \input{img/state_trajectory.pgf}      
 \caption{State trajectory plot created with \mpl}
 \label{fig:Test}
\end{figure} 
\newpage

\section{Animation using \mpl}
\label{sec:animation}
\footnote{corresponding file: \emph{car-like\_mobile\_robot\_animation.py}}
Plotting the state trajectory is often sufficient, but sometimes it can be helpful to have a visiual represantation of the system to get a better understanding of what is actually happening. This applies especially for mechanical systems.
\mpl provides the sub-package \emph{animation}, which can be used for such a purpose. We therefore need to add 
\begin{lstlisting}
from matplotlib import animation
\end{lstlisting}
to the top of our code. We encapsulate all functions for the animation in a function \emph{car\_animation()}. At first we create a figure like we did in \ref{sec:plot}.
\lstinputlisting[numbers=left,firstnumber=96,firstline=96,lastline=121]{../sim/car-like_mobile_robot_animation.py}
Now we want to display a representation of our car in the figure. We do this by plotting lines. All lines that represent the car are defined by points, which depend on the current state $\x$ and control signal $\uu$. This means we need to define a function inside \emph{car\_animation()} that maps from $\x$ and $\uu$ to a set of points in the $(Y_1,Y_2)$-plane using geometry and passes these to the plot instance \emph{car}.
\lstinputlisting[numbers=left,firstnumber=122,linerange={122-152}]{../sim/car-like_mobile_robot_animation.py}
$\dots$
\lstinputlisting[numbers=left,firstnumber=170,linerange={170-180}]{../sim/car-like_mobile_robot_animation.py}
For the animation to work we need to define another two functions, \emph{init()} and \emph{animate(i)}. The \emph{init()}-function defines which objects change during the animation.
\lstinputlisting[numbers=left,firstnumber=182,firstline=182,lastline=191]{../sim/car-like_mobile_robot_animation.py}
The \emph{animate(i)}-function assigns data to the changing objects, in our case the car and trajectory plots and the simulation time.
\lstinputlisting[numbers=left,firstnumber=193,firstline=193,lastline=207]{../sim/car-like_mobile_robot_animation.py}
Finally we have to pass these functions and the figure we created to \emph{animation.FuncAnimation()}.
\lstinputlisting[numbers=left,firstnumber=209,firstline=209,lastline=216]{../sim/car-like_mobile_robot_animation.py}
Now we have all things set up to simulate our system and animate it.
\lstinputlisting[numbers=left,firstnumber=244,firstline=244,lastline=247]{../sim/car-like_mobile_robot_animation.py}
\newpage
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.7\textwidth]{img/animation}
	\caption{Car animation}
	\label{fig:animation}
\end{figure}


\newpage
\section{Simulation with SciPy's new \emph{solve\_ivp} module and the \emph{lambda} function}
\footnote{corresponding file: \emph{car-like\_mobile\_robot\_lambda.py}}
In addition to the solution in \autoref{sec:simulation} using \emph{odeint}, SciPy's integrate package contains some newer solver classes. To use the general \emph{solve\_ivp} class, we need to import the new package.
\begin{lstlisting}
from scipy.integrate import solve_ivp
\end{lstlisting}
Then we have to switch the arguments of our \emph{ode}-function, because in \emph{solve\_ivp} the desired order of function arguments in the ODE is different. We therefore replace
\begin{lstlisting}
def ode(x, t, prmtrs):
\end{lstlisting}
with 
\begin{lstlisting}
def ode(t, x, prmtrs):
\end{lstlisting}
Now we can call the solver.
\begin{lstlisting}
sol = solve_ivp(lambda t, x: ode(t, x, prmtrs), 
               (t0, tend), x0, method='RK45',t_eval=tt)
\end{lstlisting}
The arguments of \emph{solve\_ivp} differ from \emph{odeint}. The ODE must have the form $f(t,x)$. In order to use \emph{ode(t, x, prmtrs)}, which takes 3 arguments, we need to use a \emph{lambda} function. This way we encapsulate the ODE in an anonymous function, that has just $(t, x)$ as arguments and can be evaluated by \emph{solve\_ivp}.\footnote{the lambda function corresponds to @ in \emph{MATLAB}} After the ODE is passed the solver takes the following arguments: a tuple $(t0, tend)$ which defines the simulation interval, the initial value $x0$. Additionally we pass the optional arguments \emph{method}, in this case a Runge-Kutta method and \emph{t\_eval}, which defines the values at which the solution should be sampled. 
The return value \emph{sol} is an \emph{OdeResult} object. To extract the simulated state trajectory, we execute:
\begin{lstlisting}
x_traj = sol.y.T # size=len(x)*len(tt) (.T -> transpose)
\end{lstlisting}

\newpage
\section{(Differential) flatness based tracking control}
For controlling a nonlinear system like \eqref{eq:ss_system}, linear control methods are not sufficient. We therefore use an advanced control method called (differential) flatness based tracking control, where we design a model based feedforward control and stabilize the system along a planned state trajectory.
\subsection{(Differential) flatness}
A system $\dot{\x}=f(\x,\uu)$ is called (differntially) flat, if a tuple of differential independent variables exists, from which we can derive all other system variables $\z=(\x,\uu)$, without solving an ODE. Such a tuple is called a flat output $\y=h(\x)$. The flat output has $m = s-q$ components, where $s$ is the number of system variables and $q$ is the number of equations. In system \eqref{eq:syseq}, we have 5 system variables $(y_1,y_2, \theta,v, \phi) $ and 3 equations, a flat output must therefore have 2 components. A flat output is $\y=(y_1,y_2)$. We now want to show, that a function $\z = \mathbf{\psi}(\y,\dot{\y},...,\y^{(\alpha)})$ for $\y=(y_1,y_2)$ exists.

Recapture system \eqref{eq:syseq} from \autoref{sec:model}:
\setcounter{equation}{0}
\begin{subequations}
\label{eq:1}
\begin{align}
\dot{y}_1&=v \cos (\theta) \label{eq:1a}\\
\dot{y}_2&=v \sin (\theta) \label{eq:1b}\\
\tan(\phi) &= \frac{l\dot{\theta}}{v} \label{eq:1c}
\end{align}
\end{subequations}
\setcounter{equation}{2}
Dividing \eqref{eq:1b} by \eqref{eq:1a} leads to:
\begin{subequations}
\begin{align}
\frac{\dot{y}_2}{\dot{y}_1} &=\tan(\theta) \label{eq:3a}\\
\Leftrightarrow  \theta &= \arctan\left(\frac{\dot{y}_2}{\dot{y}_1}\right) \label{eq:3b}
\end{align}
\end{subequations}
The velocity $v$ can be derived from the time derivative of the position vector $\y$.
\begin{align}
\label{eq:4}
v =\left| \mathbf{v} \right| = \left| \dot{\y} \right| = \sqrt{\dot{y}_1^2+\dot{y}_2^2}
\end{align}
We take the derivative of \eqref{eq:3b} and \eqref{eq:4} insert the result in \eqref{eq:1c}:
\begin{subequations}
\begin{align}
\tan(\phi) &= \frac{l}{\underbrace{\sqrt{\dot{y}_1^2+\dot{y}_2^2}}_{v}} \underbrace{\frac{\ddot{y}_1 \dot{y}_2 - \dot{y}_1 \ddot{y}_2}{(\dot{y}_1^2+\dot{y}_2^2)}}_{\dot{\theta}}\label{eq:5a} \\
\Leftrightarrow \phi &= \arctan\left(l \frac{\ddot{y}_1 \dot{y}_2 - \dot{y}_1 \ddot{y}_2}{(\dot{y}_1^2+\dot{y}_2^2)^{\frac{3}{2}}} 
\right) \label{eq:5b}
\end{align}
\end{subequations}
Now we have found $\z = \mathbf{\psi}(\y,\dot{\y},...,\y^{(\alpha)})$:
\begin{align}
\begin{pmatrix} z_1 \\ z_2 \\ z_3 \\ z_4 \\ z_5 \end{pmatrix} = 
\begin{pmatrix} x_1 \\ x_2 \\ x_3 \\ u_1 \\ u_2 \end{pmatrix} = 
\begin{pmatrix} y_1 \\ y_2 \\ \theta \\v \\  \phi \end{pmatrix} =
\begin{pmatrix} y_1 \\ y_2 \\  \arctan\left(\frac{\dot{y}_2}{\dot{y}_1}\right)\\ \sqrt{\dot{y}_1^2+\dot{y}_2^2}\\ \arctan\left(l \frac{\ddot{y}_1 \dot{y}_2 - \dot{y}_1 \ddot{y}_2}{(\dot{y}_1^2+\dot{y}_2^2)^{\frac{3}{2}}} 
\right) \end{pmatrix}
\end{align}
$\y = (y_1, y_2)$ is indeed a flat output.
%\subsection{Transformation to BINF, determine control laws}
\subsection{Dynamic state feedback via exact input-output linearization}
In order to determine a control law we linearize the system by defining a new input $\mathbf{w}=(w_1,w_2)$. To do this we have to take the derivative of the flat output $\y$, until the input $\uu$ shows up explicitly. 
\begin{subequations}
\begin{align}
y_1 &= x_1 \\
y_2 &= x_2 \\
\dot{y}_1 &= \dot{x}_1 = u_1 \cos(x_3)\\
\dot{y}_2 &= \dot{x}_2 = u_1 \sin(x_3) \overset{!}{=} w_1 \label{eq:7d}\\
\ddot{y}_1 &= \frac{\d}{\d t}(u_1 \cos(x_3)) = \dot{u}_1 \cos(x_3) - \frac{1}{l}u_1^2\sin(x_3)\tan(u_2) \overset{!}{=} w_2 \label{eq:7e}
\end{align}
\end{subequations}
With a generalized state vector $\mathbf{q} = (q_1,q_2,q_3)^\textrm{T}=(y_1,\dot{y}_1,y_2)^\textrm{T}$ we now get a new linear state space model $\dot{\mathbf{q}}=g(\mathbf{q},\mathbf{w})$:
\begin{align}
\label{eq:8}
\begin{pmatrix}
\dot{q}_1 \\\dot{q}_2 \\ \dot{q}_3
\end{pmatrix}
=
\begin{pmatrix}
q_2 \\ w_2 \\ w_1
\end{pmatrix}
\end{align}
\subsubsection{Stabilizing the linearized system}
To stabilize system \eqref{eq:8}, we define a differential equation for the tracking error $\mathbf{e}=\y-\y_d$:
\begin{align}
\label{eq:9}
0 = \ddot{\mathbf{e}} + \mathbf{K}_1 \dot{\mathbf{e}}+\mathbf{K}_0 \mathbf{e}
\end{align}
We choose the matrices $\mathbf{K}_0$ and $\mathbf{K}_1$ such that the ODE is stable.
If we solve \eqref{eq:9} for $\mathbf{w}$ we get:
\begin{subequations}
\label{eq:10}
\begin{align}
w_1 &=  \dot{y}_2 =\dot{y}_{2,d} - k_{0,2}(y_2-y_{2,d}) \\
w_2 &= \ddot{y}_1 = \ddot{y}_{1,d} - k_{1,1}(\dot{y}_1-\dot{y}_{1,d})-k_{0,1}(y_1-y_{1,d})
\end{align}
\end{subequations}
\subsubsection{Control law}
To determine the control laws, we first substitute \eqref{eq:10} into \eqref{eq:7d} and solve for $u_1$. 
\begin{subequations}
\begin{align}
&u_1 = \frac{w_1}{\sin{x_3}} \\
\Leftrightarrow \quad & u_1 = \frac{\dot{y}_{2,d} - k_{0,2}(y_2-y_{2,d})}{\sin{x_3}} \\
\Leftrightarrow \quad & u_1 = \frac{\dot{y}_{2,d} - k_{0,2}(y_2-y_{2,d})}{\sin{\left(\arctan\left(\frac{\dot{y}_2}{\dot{y}_1}\right)\right)}}
\end{align}
\end{subequations}

%\begin{subequations}
%\begin{align}
%&\dot{u}_1 \cos(x_3) - \frac{1}{l}u_1^2\sin(x_3)\tan(u_2) = w_2 \\
%\Leftrightarrow \quad & \frac{1}{l}u_1^2\sin(x_3)\tan(u_2) = \dot{u}_1 \cos(x_3) - w_2  \\
%\Leftrightarrow \quad & \tan(u_2) = \frac{l}{u_1^2\sin(x_3)}\left(\dot{u}_1 \cos(x_3) - w_2 
%\right)  \\
%\Leftrightarrow \quad & u_2 = \arctan\left(\frac{l}{u_1^2\sin(x_3)}\left(\dot{u}_1 \cos(x_3) - w_2 
%\right)
%\right)
%\end{align}
%\end{subequations}

Then substitute $\mathbf{w}$ in \eqref{eq:5b}:
\begin{subequations}
\begin{align}
u_2 &= \arctan\left(l \frac{\ddot{y}_1 \dot{y}_2 - \dot{y}_1 \ddot{y}_2}{(\dot{y}_1^2+\dot{y}_2^2)^{\frac{3}{2}}} 
\right) \\
&= \arctan\left(l \frac{w_2 w_1 - \dot{y}_1 \dot{w}_1}{(\dot{y}_1^2+w_1^2)^{\frac{3}{2}}} 
\right) 
\end{align}
\end{subequations}
The derivative of $w_1$ appears in the feedback law. We therefore have to derive the equation for it:
\begin{subequations}
\begin{align}
\dot{w}_1 = \ddot{y}_2 = \frac{\d w_1}{\d t} &= \frac{\d}{\d t}(\dot{y}_{2,d} - k_{0,2}(y_2-y_{2,d})) \\
&=\ddot{y}_{2,d} - k_{0,2}(\underbrace{\dot{y}_2}_{=w_1}-\dot{y}_{2,d}) \\
&=\ddot{y}_{2,d} - k_{0,2}(\dot{y}_{2,d} - k_{0,2}(y_2-y_{2,d})-\dot{y}_{2,d}) \\
\Leftrightarrow \quad \dot{w}_1&=\ddot{y}_{2,d} - k_{0,2}^2(y_2-y_{2,d})
\end{align}
\end{subequations}
\subsection{Calculating a reference trajectory (path planner)}
Now that we have defined the control law we need to develop a path planner, that calculates a feasible trajectory of the flat output and its derivitives (to the second order) for a given state transition.

\centering{\textcolor{red}{figure: showing a state transition}}

\subsection{Implementation of the controller in \py}
\centering{\textcolor{red}{work in progress}}

%\subsection{Plotresults}
\end{document}
