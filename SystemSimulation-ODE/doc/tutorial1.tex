\documentclass[a4paper,11pt,headings=standardclasses]{scrartcl}% see <http://www.komascript.de>
% ----------------------------------------------------------------------------
% font, style, etc.
\usepackage[utf8]{inputenc} % defines
\usepackage{csquotes}

% mathematics
\usepackage{amsmath}
\usepackage{amssymb}

% figures, tables, etc.
\usepackage{hyperref} %
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{pgf}
\usepackage{xcolor}

% code
\usepackage{listings}
\lstset{
language=Python, 
backgroundcolor = \color{light-gray},
basicstyle=\scriptsize\sffamily,
stringstyle=\color{orange},
breaklines=true,
numberstyle=\tiny\color{gray},
keywordstyle=\bfseries\color{dark-blue}\textit, % print keywords dark-blue
commentstyle=\color{dark-green}, % print comments dark-green
showstringspaces=false} % spacing between strings not showed

% others
\usepackage{acronym}

% theorems
\newtheorem{defi}{Definition}[section]

% setup the appearance of links
\hypersetup{
    colorlinks = true, % false -> red box arround links (not very nice)
    linkcolor={red!20!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black},
}

% define shortcuts
\newcommand{\ad}{\mathrm{ad}}
\renewcommand{\d}{\mathrm{d}} % d vor differential forms
\newcommand{\NV}{{\cal N}\,}
\newcommand{\rang}{\mathrm{rang}}
\newcommand{\im}{\mathrm{im}}
\newcommand{\spann}{\mathrm{span}}
\newcommand{\R}{\mathbb{R}} %  set of real numbers
\newcommand{\py}{\emph{Python}\,}
\newcommand{\scipy}{\emph{SciPy}\,}
\newcommand{\mpl}{\emph{Matplotlib}\,}

% color definitions
\definecolor{light-gray}{gray}{0.95}
\definecolor{dark-blue}{rgb}{0, 0, 0.5}
\definecolor{dark-red}{rgb}{0.5, 0, 0}
\definecolor{dark-green}{rgb}{0, 0.5, 0}
\definecolor{gray}{rgb}{0.5, 0.5, 0.5}

% ----------------------------------------------------------------------------
%\titlehead{Prof. Dr.-Ing. habli. Dipl.-Math. Klaus RÃ¶benack \\ Institute of Control Theory \\ Faculty of Electrical and Computer Engineering \\TU Dresden, Germany}% optional
\subject{Control Theory Tutorial}% optional
\title{Car-Like Mobile Robot}
\subtitle{\py for simulation, animation and control}% optional
\author{}
\date{}
%\publishers{}% optional
% ----------------------------------------------------------------------------

\begin{document}
\maketitle% create title
\tableofcontents
\newpage
\section{Introduction}
The goal of this tutorial is to teach the usage of the programming language \py as a tool for developing and simulating control systems.

\section{Model of a car-like mobile robot}
\begin{figure}[ht]
	\centering
	\def\svgwidth{0.7\textwidth}
	\input{img/car-like_mobile_robot.pdf_tex}
	\caption{Car-like mobile robot}
	\label{fig:car}
\end{figure}
Given is a nonlinear kinematic model of a car-like mobile robot, with the following system variables: position $(y_1, y_2)$ and orientation $\theta$ in the plane, the steering angle $\phi$ and the robots lateral velocity $v=\left| \vec{v} \right| $. 
\begin{subequations}\label{eq:syseq}
\begin{align}
\dot{y_1}&=v \cos (\theta) \\
\dot{y_2}&=v \sin (\theta) \\
\tan(\phi) &= \frac{l\dot{\theta}}{v}
\end{align}
\end{subequations}
To simulate this system of 1st order ordinary differential equations (ODEs), we define a state vector $\mathbf{x}=(x_1,x_2,x_3)^\mathrm{T}$ and a control vector $\mathbf{u}=(u_1,u_2)^\mathrm{T}$:
\begin{align*}
x_1 &= y_1 & u_1 = v\\
x_2 &= y_2 & u_2 = \phi \\
x_3 &= \theta 
\end{align*}
Now we can express \eqref{eq:syseq} in a general form $\dot{\mathbf{x}}=f(\mathbf{x},\mathbf{u})$:
\label{eq:ss_system}
\begin{align}
\underbrace{\begin{pmatrix} \dot{x}_1 \\ \dot{x}_2 \\ \dot{x}_3 \end{pmatrix}}_{\dot{\mathbf{x}}} = \underbrace{\begin{pmatrix}  u_1 \cos(x_3) \\ u_1 \sin(x_3) \\ \frac{1}{l}u_1 \tan(u_2) \end{pmatrix}}_{f(\mathbf{x},\mathbf{u})}
\end{align}

\section{Storing parameters}
We store the parameters of our system in a class \emph{Parameters()}.
\begin{lstlisting}
class Parameters(object):
    pass
\end{lstlisting}
We therefore create an entity of \emph{Parameters()} and assign attributes.
\begin{lstlisting}
prmtrs = Parameters() # entity of class Parameters
prmtrs.l = 0.3 # define car length
prmtrs.w = prmtrs.l*0.3 # define car width
\end{lstlisting}

\section{Libraries and Packages}
In order to use $\cos(\cdot), \sin(\cdot)$ and $\tan(\cdot)$ we need to import these functions at the beginning of our code from the \emph{numpy} library.
\begin{lstlisting}
import numpy as np 
from numpy import cos, sin, tan
\end{lstlisting}
To simulate \eqref{eq:ss_system} we need to solve an initial value problem (IVP). In \py we can use the library \scipy and its sub-package \emph{integrate}, which delivers different solvers for IVPs.
\begin{lstlisting}
from scipy.integrate import odeint
\end{lstlisting}
For plotting the output of our simulation, we use the library \mpl and its sub-package \emph{pyplot}, which delivers a user experience similar to \emph{MATLAB}.
\begin{lstlisting}
import matplotlib.pyplot as plt
\end{lstlisting}
\section{Simulation with SciPy's integrate package}
\label{sec:simulation}
\footnote{corresponding file: \emph{car-like\_mobile\_robot\_plotting.py}}
To simulate \eqref{eq:ss_system} we need to implement the ODE system as a function in \py.
\lstinputlisting[numbers=left,firstnumber=7,firstline=7,lastline=26]{../sim/car-like_mobile_robot_plotting.py}
The control law is also implemented as function.
\lstinputlisting[numbers=left,firstnumber=29,firstline=29,lastline=41]{../sim/car-like_mobile_robot_plotting.py}
As a first simple heuristic, we set $(u_1, u_2)$ equal to constant values. Later we can implement an arbitrary function, for expample a feedback law $\mathbf{u}=k(\mathbf{x})$.

\subsection{Solution of the initial value problem (IVP) using \scipy}
We then define the simulation time and the initial state value.
\lstinputlisting[numbers=left,firstnumber=98,firstline=98,lastline=106]{../sim/car-like_mobile_robot_plotting.py}
Now we can parse these parameters and our ODE function to the solver.
\lstinputlisting[numbers=left,firstnumber=108,firstline=108,lastline=110]{../sim/car-like_mobile_robot_plotting.py}
The output is an array of size length(tt)$\times$length($\mathbf{x}$).

\section{Plotting using \mpl}
\label{sec:plot}
We encase our plotting instructions in a function. This way, we can define parameters of our plot, which we would like to change easily, for example figure width, or if the figure should be saved on the hard drive.
% def plot_data():
\lstinputlisting[numbers=left,firstnumber=44,firstline=44,lastline=91]{../sim/car-like_mobile_robot_plotting.py}
Now that we have defined our plotting function, we  can execute it with the calculated trajectories and our desired values for the functions parameters.
\lstinputlisting[numbers=left,firstnumber=115,firstline=115,lastline=118]{../sim/car-like_mobile_robot_plotting.py}
If your not satisfied with the result, you can change other properties of the plot, like linewidth or -color and many others easily. Just look up the documentation of \mpl : \url{https://matplotlib.org/index.html}
\begin{figure}[h]
\label{fig:state_traj}
   \centering      
   \input{img/state_trajectory.pgf}      
 \caption{State trajectory plot created with \mpl}
 \label{fig:Test}
\end{figure} 
\newpage

\section{Animation using \mpl}
\label{sec:animation}
\footnote{corresponding file: \emph{car-like\_mobile\_robot\_animation.py}}
Plotting the state trajectory is often sufficient, but sometimes it can be helpful to have a visiual represantation of the system to get a better understanding of what is actually happening. This applies especially for mechanical systems.
\mpl provides the sub-package \emph{animation}, which can be used for such a purpose. We therefore need to add 
\begin{lstlisting}
from matplotlib import animation
\end{lstlisting}
to the top of our code. We encapsulate all functions for the animation in a function \emph{car\_animation()}. At first we create a figure like we did in \ref{sec:plot}.
\lstinputlisting[numbers=left,firstnumber=96,firstline=96,lastline=121]{../sim/car-like_mobile_robot_animation.py}
Now we want to display a representation of our car in the figure. We do this by plotting lines. All lines that represent the car are defined by points, which depend on the current state $\mathbf{x}$ and control signal $\mathbf{u}$. This means we need to define a function inside \emph{car\_animation()} that maps from $\mathbf{x}$ and $\mathbf{u}$ to a set of points in the $(Y_1,Y_2)$-plane using geometry and passes these to the plot instance \emph{car}.
\lstinputlisting[numbers=left,firstnumber=122,linerange={122-152}]{../sim/car-like_mobile_robot_animation.py}
$\dots$
\lstinputlisting[numbers=left,firstnumber=170,linerange={170-180}]{../sim/car-like_mobile_robot_animation.py}
For the animation to work we need to define another two functions, \emph{init()} and \emph{animate(i)}. The \emph{init()}-function defines which objects change during the animation.
\lstinputlisting[numbers=left,firstnumber=182,firstline=182,lastline=191]{../sim/car-like_mobile_robot_animation.py}
The \emph{animate(i)}-function assigns data to the changing objects, in our case the car and trajectory plots and the simulation time.
\lstinputlisting[numbers=left,firstnumber=193,firstline=193,lastline=207]{../sim/car-like_mobile_robot_animation.py}
Finally we have to pass these functions and the figure we created to \emph{animation.FuncAnimation()}.
\lstinputlisting[numbers=left,firstnumber=209,firstline=209,lastline=216]{../sim/car-like_mobile_robot_animation.py}
Now we have all things set up to simulate our system and animate it.
\lstinputlisting[numbers=left,firstnumber=244,firstline=244,lastline=247]{../sim/car-like_mobile_robot_animation.py}
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.65\textwidth]{img/animation}
	\caption{Car animation}
	\label{fig:animation}
\end{figure}
\newpage
\section{Simulation with SciPy's new \emph{solve\_ivp} module and the \emph{lambda} function}
\footnote{corresponding file: \emph{car-like\_mobile\_robot\_lambda.py}}
In addition to the shown solution in \ref{sec:simulation} using \emph{odeint}, SciPy's integrate package contains new solver classes. To use it we have to do some small changes to our script. At first we need to import the new package.
\begin{lstlisting}
from scipy.integrate import solve_ivp
\end{lstlisting}
Then we have to switch the arguments of our \emph{ode}-function, because in \emph{solve\_ivp} the desired order of function arguments in the ODE is different. We therefore replace
\begin{lstlisting}
def ode(x, t, prmtrs):
\end{lstlisting}
with 
\begin{lstlisting}
def ode(t, x, prmtrs):
\end{lstlisting}
Now we can call the solver.
\begin{lstlisting}
sol = solve_ivp(lambda t, x: ode(t, x, prmtrs), 
               (t0, tend), x0, method='RK45',t_eval=tt)
\end{lstlisting}
The function argument of \emph{solve\_ivp} must have the form $f(t,x)$. In order to use our defined ODE function, which takes 3 arguments, we need to use a \emph{lambda} function. This way we encapsulate our ODE in an anonymous function, that takes just $(t, x)$ as arguments and can be evaluated by \emph{solve\_ivp}. \footnote{the lambda function corresponds to @ in \emph{MATLAB}}
The return value \emph{sol} is an \emph{OdeResult} object. To extract the simulated state trajectory, we execute:
\begin{lstlisting}
x_traj = sol.y.T # size=len(x)*len(t) (.T -> transpose)
\end{lstlisting}
%\section{(Differential) flatness based tracking control}
%\subsection{Transformation to BINF, determine control laws}
%\subsection{Creating the reference trajectory (path planner)}
%\subsection{Implementation of the controller}
%\subsection{Plotresults}
\end{document}
